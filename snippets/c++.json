{
  "main": {
    "prefix": "cpp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define int long long",
      "#ifdef ONPC",
      "#include \"mydebug.h\"",
      "#else",
      "#define debug(...) 1",
      "#endif",
      "",
      "void solve(){",
      "",
      "}",
      "",
      "int32_t main(){",
      "  ios::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "  int n = 1;",
      "  cin>>n;",
      "  for(int i=1;i<=n;i++) {",
      "      //cout<<\"Case \"<<i<<\": \";",
      "      solve();",
      "  }",
      "}",
      ""
    ],
    "description": "mainTestCase"
  },
  "singleTestCase": {
    "prefix": "Cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define int long long",
      "#ifdef ONPC",
      "#include \"mydebug.h\"",
      "#else",
      "#define debug(...) 1",
      "#endif",
      "",
      "int32_t main(){",
      "  ios::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "  int n;",
      "}",
      ""
    ],
    "description": "singleTestCase"
  },
  "bfs_algorithm": {
    "prefix": "bfs_algorithm",
    "body": [
      "void bfs(int start, int target = -1){",
      "  queue<int>q;",
      "  q.push(start);",
      "  vis[start] = true;",
      "  while(!q.empty()){",
      "    int u = q.front();",
      "    q.pop();",
      "    for(int i:adj[u]){",
      "      if(!vis[i]){",
      "        vis[i] = true;",
      "        q.push(i);",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      ""
    ],
    "description": "bfs_algorithm"
  },
  "nCr": {
    "prefix": "nCr",
    "body": [
      "int inverseMod(int a, int m) { return power(a, m - 2); }",
      "",
      "int nCr(int n, int r, int m = mod){",
      "   if(r==0) return 1;",
      "   if(r>n) return 0;",
      "   return (fact[n] * inverseMod((fact[r] * fact[n-r]) % m , m)) % m;",
      "}",
      "",
      ""
    ],
    "description": "nCr"
  },
  "power": {
    "prefix": "power",
    "body": [
      "int power(int base, int n, int m = mod) {",
      "  if (n == 0) return 1;",
      "  if (n & 1) {",
      "    int x = power(base, n / 2);",
      "    return ((x * x) % m * base) % m;",
      "  }",
      "  else {",
      "    int x = power(base, n / 2);",
      "    return (x * x) % m;",
      "  }",
      "}",
      ""
    ],
    "description": "power"
  },
  "random": {
    "prefix": "random",
    "body": [
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "",
      "inline int gen_random(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }",
      "",
      "gen_random(l, r);",
      ""
    ],
    "description": "random"
  },
  "DisjointSet": {
    "prefix": "DisjointSet",
    "body": [
      "class DisjointSet {",
      "  vector<int> parent, sz;",
      "",
      " public:",
      "  DisjointSet(int n) {",
      "    sz.resize(n + 1);",
      "    parent.resize(n + 2);",
      "    for (int i = 1; i <= n; i++) parent[i] = i, sz[i] = 1;",
      "  }",
      "  int findUPar(int u) { return parent[u] == u ? u : parent[u] = findUPar(parent[u]); }",
      "  void unionBySize(int u, int v) {",
      "    int a = findUPar(u);",
      "    int b = findUPar(v);",
      "    if (sz[a] < sz[b]) swap(a, b);",
      "    if (a != b) {",
      "      parent[b] = a;",
      "      sz[a] += sz[b];",
      "    }",
      "  }",
      "};",
      ""
    ],
    "description": "DisjointSet"
  },
  "Krushkal": {
    "prefix": "Krushkal",
    "body": [
      "vector<pair<int, pair<int, int>>> Krushkal(vector<pair<int, pair<int, int>>> &edges, int n) {",
      "  sort(edges.begin(), edges.end());",
      "  vector<pair<int, pair<int, int>>> ans;",
      "  DisjointSet D(n);",
      "  for (auto it : edges) {",
      "    if (D.findUPar(it.second.first) != D.findUPar(it.second.second)) {",
      "      ans.push_back({it.first, {it.second.first, it.second.second}});",
      "      D.unionBySize(it.second.first, it.second.second);",
      "    }",
      "  }",
      "  return ans;",
      "}",
      ""
    ],
    "description": "Krushkal"
  },
  "Prims": {
    "prefix": "Prims",
    "body": [
      "void Prims(int start) {",
      "  // map<int, vector<pair<int, int>>> adj, ans;",
      "  priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;",
      "  pq.push({0, {start, -1}});",
      "  while (!pq.empty()) {",
      "    auto it = pq.top();",
      "    pq.pop();",
      "    int wt = it.first;",
      "    int u = it.second.first;",
      "    int v = it.second.second;",
      "    if (vis[u]) continue;",
      "    vis[u] = 1;",
      "    if (v != -1) ans[u].push_back({v, wt});",
      "    for (pair<int, int> i : adj[u]) {",
      "      int adjWt = i.second;",
      "      int adjNode = i.first;",
      "      if (!vis[adjNode]) pq.push({adjWt, {adjNode, u}});",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "Prims"
  },
  "MillerRabin": {
    "prefix": "MillerRabin",
    "body": [
      "using u64 = uint64_t;",
      "using u128 = __uint128_t;",
      "",
      "u64 binpower(u64 base, u64 e, u64 mod) {",
      "  u64 result = 1;",
      "  base %= mod;",
      "  while (e) {",
      "    if (e & 1) result = (u128)result * base % mod;",
      "    base = (u128)base * base % mod;",
      "    e >>= 1;",
      "  }",
      "  return result;",
      "}",
      "",
      "bool check_composite(u64 n, u64 a, u64 d, int s) {",
      "  u64 x = binpower(a, d, n);",
      "  if (x == 1 || x == n - 1) return false;",
      "  for (int r = 1; r < s; r++) {",
      "    x = (u128)x * x % n;",
      "    if (x == n - 1) return false;",
      "  }",
      "  return true;",
      "};",
      "",
      "bool MillerRabin(u64 n, int iter = 5) {  // returns true if n is probably prime, else returns false.",
      "  if (n < 4) return n == 2 || n == 3;",
      "  int s = 0;",
      "  u64 d = n - 1;",
      "  while ((d & 1) == 0) {",
      "    d >>= 1;",
      "    s++;",
      "  }",
      "",
      "  for (int i = 0; i < iter; i++) {",
      "    int a = 2 + rand() % (n - 3);",
      "    if (check_composite(n, a, d, s)) return false;",
      "  }",
      "  return true;",
      "}",
      ""
    ],
    "description": "MillerRabin"
  },
  "Sieve": {
    "prefix": "Sieve",
    "body": [
      "const int sieve_size = 10000006;",
      "bitset<sieve_size> sieve;",
      "",
      "void Sieve() {",
      "  sieve.flip();",
      "  int finalBit = sqrt(sieve.size()) + 1;",
      "  for (int i = 2; i < finalBit; ++i) {",
      "    if (sieve.test(i))",
      "      for (int j = 2 * i; j < sieve_size; j += i) sieve.reset(j);",
      "  }",
      "}",
      ""
    ],
    "description": "Sieve"
  },
  "bitManip": {
    "prefix": "bitManip",
    "body": [
      "#define SetBit(x, k) (x |= (1LL << k))",
      "#define ClearBit(x, k) (x &= ~(1LL << k))",
      "#define CheckBit(x, k) ((x >> k) & 1)",
      ""
    ],
    "description": "bitManip"
  },
  "segmentTree": {
    "prefix": "segmentTree",
    "body": [
      "constexpr int N = 100005;",
      "int arr[N], seg[N];",
      "",
      "void build(int ind, int low, int high) {",
      "  if (low == high) {",
      "    seg[ind] = arr[low];",
      "    return;",
      "  }",
      "  int mid = (low + high) / 2;",
      "  build(2 * ind + 1, low, mid);",
      "  build(2 * ind + 2, mid + 1, high);",
      "  seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];",
      "}",
      "int query(int ind, int low, int high, int l, int r) {",
      "  if (low >= l && high <= r) return seg[ind];",
      "  if (low > r || high < l) return 0;",
      "  int mid = (low + high) / 2;",
      "  int left = query(2 * ind + 1, low, mid, l, r);",
      "  int right = query(2 * ind + 2, mid + 1, high, l, r);",
      "  return left + right;",
      "}",
      "void update(int ind, int low, int high, int node, int val) {",
      "  if (low == high) {",
      "    seg[ind] = val;",
      "    return;",
      "  }",
      "  int mid = (low + high) / 2;",
      "  if (low <= node && node <= mid) update(2 * ind + 1, low, mid, node, val);",
      "  else update(2 * ind + 2, mid + 1, high, node, val);",
      "  seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];",
      "}",
      ""
    ],
    "description": "segmentTree"
  },
  "Dijkstra": {
    "prefix": "Dijkstra",
    "body": [
      "void Dijkstra(int start) {",
      "  // map<int, vector<pair<int, int>>> adj;",
      "  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
      "  pq.push({0, start});",
      "  while (!pq.empty()) {",
      "    auto it = pq.top();",
      "    pq.pop();",
      "    int wt = it.first;",
      "    int u = it.second;",
      "    if (vis[u]) continue;",
      "    vis[u] = 1;",
      "    for (pair<int, int> i : adj[u]) {",
      "      int adjWt = i.second;",
      "      int adjNode = i.first;",
      "      if (dist[adjNode] > wt + adjWt) {",
      "        dist[adjNode] = wt + adjWt;",
      "        pq.push({dist[adjNode], adjNode});",
      "      }",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "Dijkstra"
  },
  "fenwickTree": {
    "prefix": "fenwickTree",
    "body": [
      "int fenwick[N];",
      "",
      "void update(int ind, int val) {",
      "  while (ind < N) {",
      "    fenwick[ind] += val;",
      "    ind += ind & -ind;",
      "  }",
      "}",
      "int query(int ind) {",
      "  int sum = 0;",
      "  while (ind > 0) {",
      "    sum += fenwick[ind];",
      "    ind -= ind & -ind;",
      "  }",
      "  return sum;",
      "}",
      ""
    ],
    "description": "fenwickTree"
  },
  "modInverse": {
    "prefix": "modInverse",
    "body": [
      "int modInverse(int a, int m) {",
      "  int m0 = m, t, q;",
      "  int x0 = 0, x1 = 1;",
      "  if (m == 1) return 0;",
      "  while (a > 1) {",
      "    q = a / m;",
      "    t = m;",
      "    m = a % m, a = t;",
      "    t = x0;",
      "    x0 = x1 - q * x0;",
      "    x1 = t;",
      "  }",
      "  if (x1 < 0) x1 += m0;",
      "  return x1;",
      "}",
      ""
    ],
    "description": "modInverse"
  },
  "sieveOf": {
    "prefix": "sieveOf",
    "body": [
      "constexpr int N = 1000005;",
      "",
      "int Prime[N + 4], kk;",
      "bool notPrime[N + 5];",
      "void SieveOf() {",
      "  notPrime[1] = true;",
      "  Prime[kk++] = 2;",
      "  for (int i = 4; i <= N; i += 2) notPrime[i] = true;",
      "  for (int i = 3; i <= N; i += 2) {",
      "    if (!notPrime[i]) {",
      "      Prime[kk++] = i;",
      "      for (int j = i * i; j <= N; j += 2 * i) notPrime[j] = true;",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "sieveOf"
  },
  "Divisors": {
    "prefix": "Divisors",
    "body": [
      "constexpr int N = 1000005;",
      "",
      "int Prime[N + 4], kk;",
      "bool notPrime[N + 5];",
      "void SieveOf() {",
      "  notPrime[1] = true;",
      "  Prime[kk++] = 2;",
      "  for (int i = 4; i <= N; i += 2) notPrime[i] = true;",
      "  for (int i = 3; i <= N; i += 2) {",
      "    if (!notPrime[i]) {",
      "      Prime[kk++] = i;",
      "      for (int j = i * i; j <= N; j += 2 * i) notPrime[j] = true;",
      "    }",
      "  }",
      "}",
      "",
      "void Divisors(int n) {",
      "  int sum = 1, total = 1;",
      "  int mnP = INT_MAX, mxP = INT_MIN, cntP = 0, totalP = 0;",
      "  for (int i = 0; i <= N && Prime[i] * Prime[i] <= n; i++) {",
      "    if (n % Prime[i] == 0) {",
      "      mnP = min(mnP, Prime[i]);",
      "      mxP = max(mnP, Prime[i]);",
      "      int k = 0;",
      "      cntP++;",
      "      while (n % Prime[i] == 0) {",
      "        k++;",
      "        n /= Prime[i];",
      "      }",
      "",
      "      sum *= (k + 1);  // NOD",
      "      totalP += k;",
      "      int s = 0, p = 1;",
      "      while (k-- >= 0) {",
      "        s += p;",
      "        p *= Prime[i];",
      "      };",
      "      total *= s;  // SOD",
      "    }",
      "  }",
      "  if (n > 1) {",
      "    cntP++, totalP++;",
      "    sum *= 2;",
      "    total *= (1 + n);",
      "    mnP = min(mnP, n);",
      "    mxP = max(mnP, n);",
      "  }",
      "  cout << mnP << \" \" << mxP << \" \" << cntP << \" \" << totalP << \" \" << sum << \" \" << total << \"\\n\";",
      "}",
      ""
    ],
    "description": "Divisors"
  },
  "monotonicStack": {
    "prefix": "monotonicStack immediate small",
    "body": [
      "for (int i = n - 1; i >= 0; i--) {",
      "  while (!stk.empty() && v[i] >= v[stk.top()]) stk.pop();",
      "  ind[i] = stk.empty() ? -1 : stk.top();",
      "  stk.push(i);",
      "}",
      "// 3 1 5 4 10",
      "// 2 2 4 4 -1",
      ""
    ],
    "description": "monotonicStack"
  },
  "lis": {
    "prefix": "lis",
    "body": [
      "void lis(vector<int> &v) {",
      "  int n = v.size();",
      "  vector<int> dp(n + 1, 1), hash(n);",
      "  int mx = 1, lastInd = 0;",
      "  for (int i = 0; i < n; i++) {",
      "    hash[i] = i;",
      "    for (int prev = 0; prev < i; prev++) {",
      "      if (v[i] > v[prev] && 1 + dp[prev] > dp[i]) {",
      "        dp[i] = 1 + dp[prev];",
      "        hash[i] = prev;",
      "      }",
      "    }",
      "    if (mx < dp[i]) {",
      "      mx = dp[i];",
      "      lastInd = i;",
      "    }",
      "  }",
      "  vector<int> printSeq;",
      "  printSeq.push_back(v[lastInd]);",
      "  while (hash[lastInd] != lastInd) {",
      "    lastInd = hash[lastInd];",
      "    printSeq.push_back(v[lastInd]);",
      "  }",
      "  reverse(printSeq.begin(), printSeq.end());",
      "  cout << mx << \"\\n\";",
      "  for (int i : printSeq) cout << i << \" \";",
      "  cout << \"\\n\";",
      "}",
      ""
    ],
    "description": "lis"
  },
  "lcs": {
    "prefix": "lcs",
    "body": [
      "string s, t;",
      "vector<vector<int>> dp(3003, vector<int>(3003, -1));",
      "vector<vector<int>> mark(3003, vector<int>(3003));",
      "",
      "int f(int i, int j) {",
      "  if (i < 0 || j < 0) return 0;",
      "  if (dp[i][j] != -1) return dp[i][j];",
      "  int res = 0;",
      "  if (s[i] == t[j]) {",
      "    mark[i][j] = 1;",
      "    res = 1 + f(i - 1, j - 1);",
      "  }",
      "  else {",
      "    int iC = f(i - 1, j);",
      "    int jC = f(i, j - 1);",
      "    if (iC > jC) mark[i][j] = 2;",
      "    else mark[i][j] = 3;",
      "    res = max(iC, jC);",
      "  }",
      "  return dp[i][j] = res;",
      "}",
      "",
      "void printWay(int i, int j) {",
      "  if (i < 0 || j < 0) return;",
      "  if (mark[i][j] == 1) printWay(i - 1, j - 1), cout << s[i];",
      "  else if (mark[i][j] == 2) printWay(i - 1, j);",
      "  else if (mark[i][j] == 3) printWay(i, j - 1);",
      "}",
      ""
    ],
    "description": "lcs"
  },
  "kmp": {
    "prefix": "kmp",
    "body": [
      "vector<int> prefix_function(string s) {",
      "    int n = (int)s.length();",
      "    vector<int> pi(n);",
      "    for (int i = 1; i < n; i++) {",
      "        int j = pi[i - 1];",
      "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
      "        if (s[i] == s[j]) j++;",
      "        pi[i] = j;",
      "    }",
      "    return pi;",
      "}",
      "",
      "vector<int> find_matches(string text, string pat) {",
      "    int n = pat.length(), m = text.length();",
      "    string s = pat + \"$\" + text;",
      "    vector<int> pi = prefix_function(s), ans;",
      "    for (int i = n; i <= n + m; i++) {",
      "        if (pi[i] == n) {",
      "            ans.push_back(i - 2 * n);",
      "        }",
      "    }",
      "    return ans;",
      "}",
      "",
      ""
    ],
    "description": "kmp"
  },
  "orderedSet": {
    "prefix": "orderedSet",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
      ""
    ],
    "description": "orderedSet"
  },
  "segmentedSieve": {
    "prefix": "segmentedSieve",
    "body": [
      "#define mx 100009",
      "",
      "vector<int> primes;",
      "",
      "void sieveOfEratosthenes() {",
      "  bool flag[mx + 1];",
      "  for (int i = 0; i <= mx; i++) flag[i] = true;",
      "  primes.push_back(2);",
      "",
      "  flag[0] = flag[1] = false;",
      "",
      "  for (int i = 4; i <= mx; i += 2) {",
      "    flag[i] = false;",
      "  }",
      "",
      "  for (int i = 3; i <= mx; i += 2) {",
      "    if (flag[i] == true)  /// i is prime",
      "    {",
      "      primes.push_back(i);",
      "      for (int j = i + i; j <= mx; j = j + i) {",
      "        flag[j] = false;  /// j is not prime",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      "void segmentedSieve(int L, int R) {",
      "  bool isPrime[R - L + 1];",
      "  for (int i = 0; i <= R - L + 1; i++) isPrime[i] = true;",
      "",
      "  if (L == 1) isPrime[0] = false;",
      "  for (int i = 0; primes[i] * primes[i] <= R; i++) {",
      "    int curPrime = primes[i];",
      "    int base = curPrime * curPrime;",
      "    if (base < L) {",
      "      base = ((L + curPrime - 1) / curPrime) * curPrime;",
      "    }",
      "    for (int j = base; j <= R; j += curPrime) isPrime[j - L] = false;",
      "  }",
      "  for (int i = 0; i <= R - L; i++) {",
      "    if (isPrime[i] == true) cout << L + i << endl;",
      "  }",
      "  cout << endl;",
      "}",
      ""
    ],
    "description": "segmentedSieve"
  },
  "pragma": {
    "prefix": "pragma",
    "body": [
      "#pragma GCC optimize(\"Ofast\")",
      "#pragma GCC target(\"avx,avx2,fma\")",
      ""
    ],
    "description": "pragma"
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "const int N = 26;",
      "class Node {",
      " public:",
      "  int EoW;",
      "  Node* child[N];",
      "  Node() {",
      "    EoW = 0;",
      "    for (int i = 0; i < N; i++) child[i] = NULL;",
      "  }",
      "};",
      "",
      "void insert(Node* node, string s) {",
      "  for (size_t i = 0; i < s.size(); i++) {",
      "    int r = s[i] - 'A';",
      "    if (node->child[r] == NULL) node->child[r] = new Node();",
      "    node = node->child[r];",
      "  }",
      "  node->EoW += 1;",
      "}",
      "",
      "int search(Node* node, string s) {",
      "  for (size_t i = 0; i < s.size(); i++) {",
      "    int r = s[i] - 'A';",
      "    if (node->child[r] == NULL) return 0;",
      "  }",
      "  return node->EoW;",
      "}",
      "",
      "void print(Node* node, string s = \"\") {",
      "  if (node->EoW) cout << s << \"\\n\";",
      "  for (int i = 0; i < N; i++) {",
      "    if (node->child[i] != NULL) {",
      "      char c = i + 'A';",
      "      print(node->child[i], s + c);",
      "    }",
      "  }",
      "}",
      "",
      "bool isChild(Node* node) {",
      "  for (int i = 0; i < N; i++)",
      "    if (node->child[i] != NULL) return true;",
      "  return false;",
      "}",
      "",
      "bool isJunc(Node* node) {",
      "  int cnt = 0;",
      "  for (int i = 0; i < N; i++) {",
      "    if (node->child[i] != NULL) cnt++;",
      "  }",
      "  if (cnt > 1) return true;",
      "  return false;",
      "}",
      "",
      "int trie_delete(Node* node, string s, int k = 0) {",
      "  if (node == NULL) return 0;",
      "  if (k == (int)s.size()) {",
      "    if (node->EoW == 0) return 0;",
      "    if (isChild(node)) {",
      "      node->EoW = 0;",
      "      return 0;",
      "    }",
      "    return 1;",
      "  }",
      "  int r = s[k] - 'A';",
      "  int d = trie_delete(node->child[r], s, k + 1);",
      "  int j = isJunc(node);",
      "  if (d) delete node->child[r];",
      "  if (j) return 0;",
      "  return d;",
      "}",
      "",
      "void delete_trie(Node* node) {",
      "  for (int i = 0; i < 15; i++) {",
      "    if (node->child[i] != NULL) delete_trie(node->child[i]);",
      "  }",
      "  delete node;",
      "}"
    ],
    "description": "trie"
  },
  "maxflow": {
    "prefix": "maxflow",
    "body": [
      "const int N = 505;",
      "int capacity[N][N];",
      "int vis[N], p[N];",
      "int n, m;",
      "",
      "int bfs(int s, int t) {",
      "  memset(vis, 0, sizeof vis);",
      "  queue<int> qu;",
      "  qu.push(s);",
      "  vis[s] = 1;",
      "  while (!qu.empty()) {",
      "    int u = qu.front();",
      "    qu.pop();",
      "    for (int i = 0; i <= n + m + 2; i++) {",
      "      if (capacity[u][i] > 0 && !vis[i]) {",
      "        p[i] = u;",
      "        vis[i] = 1;",
      "        qu.push(i);",
      "      }",
      "    }",
      "  }",
      "  return vis[t] == 1;",
      "}",
      "",
      "int maxflow(int s, int t) {",
      "  int cnt = 0;",
      "  while (bfs(s, t)) {",
      "    int cur = t;",
      "    while (cur != s) {",
      "      int prev = p[cur];",
      "      capacity[prev][cur] -= 1;",
      "      capacity[cur][prev] += 1;",
      "      cur = prev;",
      "    }",
      "    cnt++;",
      "  }",
      "  return cnt;",
      "}",
      ""
    ],
    "description": "maxflow"
  },
  "phi": {
    "prefix": "phi",
    "body": [
      "const int N = 5000005;",
      "int phi[N];",
      "unsigned long long phiSum[N];",
      "void phiCalc() {",
      "  for (int i = 2; i < N; i++) phi[i] = i;",
      "  for (int i = 2; i < N; i++) {",
      "    if (phi[i] == i) {",
      "      for (int j = i; j < N; j += i) {",
      "        phi[j] -= phi[j] / i;",
      "      }",
      "    }",
      "  }",
      "  for (int i = 2; i < N; i++) {",
      "    phiSum[i] = (unsigned long long)phi[i] * (unsigned long long)phi[i] + phiSum[i - 1];",
      "  }",
      "}",
      ""
    ],
    "description": "phi"
  },
  "log_a_base_b": {
    "prefix": "logab",
    "body": ["int logab (int a, int b){", "  return log2(a) / log2(b);", "}"],
    "description": "log_a_base_b"
  },
  "sementTreeLazy": {
    "prefix": "sementTreeLazy",
    "body": [
      "constexpr int N = 100005;",
      "int arr[N];",
      "",
      "struct {",
      "  int sum, prop;",
      "} seg[4 * N];",
      "",
      "void build(int ind, int low, int high) {",
      "  if (low == high) {",
      "    seg[ind].sum = arr[low];",
      "    seg[ind].prop = 0;",
      "    return;",
      "  }",
      "  int mid = (low + high) / 2;",
      "  build(2 * ind + 1, low, mid);",
      "  build(2 * ind + 2, mid + 1, high);",
      "  seg[ind].sum = seg[2 * ind + 1].sum + seg[2 * ind + 2].sum;",
      "  seg[ind].prop = 0;",
      "}",
      "void update(int ind, int low, int high, int l, int r, int val) {",
      "  if (l > high || r < low) return;",
      "  if (low >= l && high <= r) {",
      "    seg[ind].sum += (high - low + 1) * val;",
      "    seg[ind].prop += val;",
      "    return;",
      "  }",
      "  int mid = (low + high) / 2;",
      "  update(2 * ind + 1, low, mid, l, r, val);",
      "  update(2 * ind + 2, mid + 1, high, l, r, val);",
      "  seg[ind].sum = seg[2 * ind + 1].sum + seg[2 * ind + 2].sum + (high - low + 1) * seg[ind].prop;",
      "}",
      "int query(int ind, int low, int high, int l, int r, int carry = 0) {",
      "  if (l > high || r < low) return 0;",
      "  if (low >= l && high <= r) {",
      "    return seg[ind].sum + carry * (high - low + 1);",
      "  }",
      "  int mid = (low + high) / 2;",
      "  int q1 = query(2 * ind + 1, low, mid, l, r, carry + seg[ind].prop);",
      "  int q2 = query(2 * ind + 2, mid + 1, high, l, r, carry + seg[ind].prop);",
      "  return q1 + q2;",
      "}"
    ],
    "description": "sementTreeLazy"
  },
  "lca": {
    "prefix": "lca",
    "body": [
      "struct LCA {",
      "  vector<int> height, euler, first, segtree, parent;",
      "  vector<bool> visited;",
      "  vector<vector<int>> jump;",
      "",
      "  int n;",
      "",
      "  LCA(vector<vector<int>> &adj, int root = 0) {",
      "    n = adj.size();",
      "    height.resize(n);",
      "    first.resize(n);",
      "    parent.resize(n);",
      "    euler.reserve(n * 2);",
      "    visited.assign(n, false);",
      "    dfs(adj, root);",
      "    int m = euler.size();",
      "    segtree.resize(m * 4);",
      "    build(1, 0, m - 1);",
      "",
      "    jump.resize(n, vector<int>(32, -1));",
      "",
      "    for(int i=0;i<n;i++) {",
      "        jump[i][0] = parent[i];",
      "    }",
      "",
      "    for(int j=1;j<20;j++) {",
      "        for(int i=0;i<n;i++) {",
      "            int mid = jump[i][j-1];",
      "            if(mid != -1) jump[i][j] = jump[mid][j-1];",
      "        }",
      "    }",
      "  }",
      "",
      "  void dfs(vector<vector<int>> &adj, int node, int h = 0) {",
      "    visited[node] = true;",
      "    height[node] = h;",
      "    first[node] = euler.size();",
      "    euler.push_back(node);",
      "    for (auto to : adj[node]) {",
      "      if (!visited[to]) {",
      "        parent[to] = node;",
      "        dfs(adj, to, h + 1);",
      "        euler.push_back(node);",
      "      }",
      "    }",
      "  }",
      "",
      "  void build(int node, int b, int e) {",
      "    if (b == e) {",
      "      segtree[node] = euler[b];",
      "    } else {",
      "      int mid = (b + e) / 2;",
      "      build(node << 1, b, mid);",
      "      build(node << 1 | 1, mid + 1, e);",
      "      int l = segtree[node << 1], r = segtree[node << 1 | 1];",
      "      segtree[node] = (height[l] < height[r]) ? l : r;",
      "    }",
      "  }",
      "",
      "  int query(int node, int b, int e, int L, int R) {",
      "    if (b > R || e < L)",
      "      return -1;",
      "    if (b >= L && e <= R)",
      "      return segtree[node];",
      "    int mid = (b + e) >> 1;",
      "",
      "    int left = query(node << 1, b, mid, L, R);",
      "    int right = query(node << 1 | 1, mid + 1, e, L, R);",
      "    if (left == -1)",
      "      return right;",
      "    if (right == -1)",
      "      return left;",
      "    return height[left] < height[right] ? left : right;",
      "  }",
      "",
      "  int lca(int u, int v) {",
      "    int left = first[u], right = first[v];",
      "    if (left > right)",
      "      swap(left, right);",
      "    return query(1, 0, euler.size() - 1, left, right);",
      "  }",
      "",
      "  int kthParent(int u, int k) {",
      "      for(int i=0;i<19;i++) {",
      "          if(k & (1LL<<i)) u = jump[u][i];",
      "      }",
      "      return u;",
      "  }",
      "};"
    ],
    "description": "lca"
  }
}
